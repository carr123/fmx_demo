package main

import (
	"fmt"
	"net/url"
	"time"

	"github.com/nats-io/nats-server/v2/server"
	nats "github.com/nats-io/nats.go"
)

var (
	//szLocalIP string = "10.91.26.227"
	szLocalIP string = "10.99.25.197"
)

func main() {
	RunLeadNodeServer()
}

func RunLeadNodeServer() {

	//集群配置
	clusterOpt := server.ClusterOpts{}
	clusterOpt.Name = "cluster_leafnode1"
	clusterOpt.Host = szLocalIP
	clusterOpt.Port = 8079
	clusterOpt.Advertise = szLocalIP + ":8079"
	clusterOpt.Username = "clusteruser"
	clusterOpt.Password = "123456"

	//账户配置
	account1 := server.NewAccount("DADIBAO")
	account2 := server.NewAccount("HIGHWAY")

	user1 := &server.User{}
	user1.Account = account1
	user1.Username = "natsuser"
	user1.Password = "123456"

	user2 := &server.User{}
	user2.Account = account2
	user2.Username = "highway"
	user2.Password = "123456"

	routeURL, err := url.Parse("nats-route://clusteruser:123456@10.91.26.225:24244")
	if err != nil {
		fmt.Println("err:", err)
		return
	}

	leafCfg, err := leafnodeConf()
	if err != nil {
		fmt.Println("err:", err)
		return
	}

	natsServer, err := server.NewServer(&server.Options{
		ServerName: "embed1",
		//Host:         szLocalIP,
		//Port:         8088,
		DontListen:   false,
		JetStream:    false,
		Trace:        true,
		Debug:        true,
		TraceVerbose: true,
		LogFile:      "natsembed.log",
		MaxPayload:   1024 * 1024 * 4,
		Cluster:      clusterOpt,
		Routes:       []*url.URL{routeURL},
		Accounts:     []*server.Account{account1, account2},
		Users:        []*server.User{user1, user2},
		LeafNode:     *leafCfg,
	})
	if err != nil {
		panic(err)
	}

	go natsServer.Start()

	// if !natsServer.ReadyForConnections(time.Second * 10) {
	// 	panic("not ready in time")
	// }

	for natsServer.ClusterAddr() == nil {
		fmt.Println("not ready")
		time.Sleep(time.Millisecond * 20)
	}

	//time.Sleep(time.Second * 3)

	nc, err := nats.Connect("",
		nats.InProcessServer(natsServer),
		nats.UserInfo("highway", "123456"),
	)
	if err != nil {
		panic(err)
	}

	fmt.Println("connect OK")

	// for {
	// 	if err := nc.Publish("AAA", []byte(fmt.Sprintf("%d", time.Now().Unix()))); err != nil {
	// 		fmt.Println("Publish fail:", err)
	// 		return
	// 	}

	// 	fmt.Println("publish OK")
	// 	time.Sleep(time.Second * 3)
	// }

	nc.Subscribe("AAA", func(msg *nats.Msg) {
		fmt.Println("recv:", " topic:", msg.Subject, " data:", string(msg.Data))
	})

	time.Sleep(time.Second * 3600)
}

func leafnodeConf() (*server.LeafNodeOpts, error) {
	leafURL, err := url.Parse("nats-leaf://leafuser:abcd1234@10.91.26.226:17422")
	if err != nil {
		return nil, err
	}

	leafRemote := &server.RemoteLeafOpts{}
	leafRemote.LocalAccount = "HIGHWAY"
	leafRemote.URLs = []*url.URL{leafURL}

	leafCfg := &server.LeafNodeOpts{}
	leafCfg.ReconnectInterval = time.Second * 2
	leafCfg.Remotes = []*server.RemoteLeafOpts{leafRemote}

	return leafCfg, nil
}

type NodeServer struct {
	ClusterName       string
	Host_cluster      string
	Port_cluster      int
	Advertise_cluster string
	Peers             []string
	Hubs              []string

	account_highway *server.Account
	account_local   *server.Account
	user_highway    *server.User
	user_local      *server.User

	routes []*url.URL

	clusterOpt *server.ClusterOpts
	leafCfg    *server.LeafNodeOpts
	svr        *server.Server
}

func (t *NodeServer) Run() error {
	return nil
}

func (t *NodeServer) _init() error {

	//账户配置
	t.account_highway = server.NewAccount("HIGHWAY")
	t.account_local = server.NewAccount("LOCAL")

	t.user_highway = &server.User{}
	t.user_highway.Account = t.account_highway
	t.user_highway.Username = "highway"
	t.user_highway.Password = "123456"

	t.user_local = &server.User{}
	t.user_local.Account = t.account_local
	t.user_local.Username = "local"
	t.user_local.Password = "123456"

	//集群配置
	if len(t.Advertise_cluster) == 0 {
		t.Advertise_cluster = fmt.Sprintf("%s:%d", t.Host_cluster, t.Port_cluster)
	}

	t.clusterOpt = &server.ClusterOpts{}
	t.clusterOpt.Name = t.ClusterName
	t.clusterOpt.Host = t.Host_cluster
	t.clusterOpt.Port = t.Port_cluster
	t.clusterOpt.Advertise = t.Advertise_cluster
	t.clusterOpt.Username = "clusteruser"
	t.clusterOpt.Password = "123456"
	//t.clusterOpt.NoAdvertise = true  //不告诉客户端其他集群服务器的地址

	routeURL, err := url.Parse("nats-route://clusteruser:123456@10.91.26.226:24244")
	if err != nil {
		return err
	}

	t.routes = []*url.URL{routeURL}

	return nil
}

func (t *NodeServer) _leafnodeConf() (*server.LeafNodeOpts, error) {
	leafURL, err := url.Parse("nats-leaf://leafuser:abcd1234@10.91.26.226:17422")
	if err != nil {
		return nil, err
	}

	leafRemote := &server.RemoteLeafOpts{}
	leafRemote.LocalAccount = "HIGHWAY"
	leafRemote.URLs = []*url.URL{leafURL}

	leafCfg := &server.LeafNodeOpts{}
	leafCfg.ReconnectInterval = time.Second * 2
	leafCfg.Remotes = []*server.RemoteLeafOpts{leafRemote}

	return leafCfg, nil
}

//--------------------------------------------------------------------------------

type HubServer struct {
	ClusterName     string
	account_highway *server.Account
	user_highway    *server.User

	Host_cluster      string
	Port_cluster      int
	Advertise_cluster string
	routes            []*url.URL

	Host_leafserver      string
	Port_leafserver      int
	Advertise_leafserver string

	clusterOpt *server.ClusterOpts
	leafCfg    *server.LeafNodeOpts
	svr        *server.Server
}

func (t *HubServer) Run() error {

	if err := t._init(); err != nil {
		return err
	}

	natsServer, err := server.NewServer(&server.Options{
		ServerName: t.ClusterName + "_" + t.Advertise_cluster,
		//Host:         szLocalIP,
		//Port:         8088,
		DontListen:   false,
		JetStream:    false,
		Trace:        false,
		Debug:        false,
		TraceVerbose: false,
		//LogFile:      "natsembed.log",
		MaxPayload: 1024 * 1024 * 4,
		Cluster:    *t.clusterOpt,
		Routes:     t.routes,
		Accounts:   []*server.Account{t.account_highway},
		Users:      []*server.User{t.user_highway},
		LeafNode:   *t.leafCfg,
	})
	if err != nil {
		return err
	}

	go natsServer.Start()

	// if !natsServer.ReadyForConnections(time.Second * 10) {
	// 	panic("not ready in time")
	// }

	tBegin := time.Now()
	for natsServer.ClusterAddr() == nil {
		if time.Now().Sub(tBegin) > time.Second*5 {
			return fmt.Errorf("run server timeout")
		}
		time.Sleep(time.Millisecond * 20)
	}

	t.svr = natsServer

	return nil
}

func (t *HubServer) _init() error {
	//账户配置
	t.account_highway = server.NewAccount("HIGHWAY")

	t.user_highway = &server.User{}
	t.user_highway.Account = t.account_highway
	t.user_highway.Username = "highway"
	t.user_highway.Password = "123456"

	//集群配置
	if len(t.Advertise_cluster) == 0 {
		t.Advertise_cluster = fmt.Sprintf("%s:%d", t.Host_cluster, t.Port_cluster)
	}

	t.clusterOpt = &server.ClusterOpts{}
	t.clusterOpt.Name = t.ClusterName
	t.clusterOpt.Host = t.Host_cluster
	t.clusterOpt.Port = t.Port_cluster
	t.clusterOpt.Advertise = t.Advertise_cluster
	t.clusterOpt.Username = "clusteruser"
	t.clusterOpt.Password = "123456"
	//t.clusterOpt.NoAdvertise = true  //不告诉客户端其他集群服务器的地址

	routeURL, err := url.Parse("nats-route://clusteruser:123456@10.91.26.226:24244")
	if err != nil {
		return err
	}

	t.routes = []*url.URL{routeURL}

	//leaf server 配置
	leafuser := &server.User{}
	leafuser.Account = t.account_highway
	leafuser.Username = "leafuser"
	leafuser.Password = "abcd1234"

	if len(t.Advertise_leafserver) == 0 {
		t.Advertise_leafserver = fmt.Sprintf("%s:%d", t.Host_leafserver, t.Port_leafserver)
	}

	t.leafCfg = &server.LeafNodeOpts{}
	t.leafCfg.Host = t.Host_leafserver
	t.leafCfg.Port = t.Port_leafserver
	t.leafCfg.Advertise = t.Advertise_leafserver
	t.leafCfg.Users = []*server.User{leafuser}

	return nil
}

/*
clickhouse 入库时候DateTime字段用unix timestamp 入库。
toString(createdate, 'UTC') 强制把字段用UTC时间显示，这样与数据库安装的时区就无关了。
toString(createdate+28800, 'UTC') 强制把createdate转为东八区显示。与数据库安装的时区无关。
select id, toDate(toString(createdate+tzoffset, 'UTC')) from tb2 order by id
*/
